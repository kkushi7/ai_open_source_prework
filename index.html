<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>MMORPG Client - World Viewer</title>
    <link rel="stylesheet" href="styles.css">
  </head>
  <body>
    <canvas id="game"></canvas>
    
    <!-- Game HUD -->
    <div id="hud">
      <div class="hud-section">
        <div class="hud-title">Player Info</div>
        <div id="player-name">Loading...</div>
        <div id="player-position">Position: --, --</div>
      </div>
      
      <div class="hud-section">
        <div class="hud-title">Connection</div>
        <div id="connection-status" class="status-disconnected">Disconnected</div>
        <div id="players-online">Players: 0</div>
      </div>
      
      <div class="hud-section">
        <div class="hud-title">Controls</div>
        <div class="control-hint">Arrow Keys to Move</div>
        <div class="control-hint">WASD also works</div>
      </div>
    </div>

    <script>
      (function () {
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        const worldImage = new Image();
        worldImage.src = 'world.jpg';

        let imageLoaded = false;
        let ws = null;
        let myPlayerId = null;
        let myPlayer = null;
        let players = {};
        let avatars = {};
        let viewportX = 0;
        let viewportY = 0;
        const MAP_SIZE = 2048;
        let pressedKeys = new Set();
        let movementInterval = null;
        const MOVEMENT_INTERVAL = 50; // Send move command every 50ms for smoother movement
        let lastViewportUpdate = 0;
        
        // HUD elements
        const playerNameEl = document.getElementById('player-name');
        const playerPositionEl = document.getElementById('player-position');
        const connectionStatusEl = document.getElementById('connection-status');
        const playersOnlineEl = document.getElementById('players-online');
        
        // HUD update functions
        function updateHUD() {
          // Update player info
          if (myPlayer) {
            playerNameEl.textContent = myPlayer.username || 'Unknown';
            playerPositionEl.textContent = `Position: ${Math.round(myPlayer.x)}, ${Math.round(myPlayer.y)}`;
          }
          
          // Update connection status
          if (ws) {
            switch(ws.readyState) {
              case WebSocket.CONNECTING:
                connectionStatusEl.textContent = 'Connecting...';
                connectionStatusEl.className = 'status-connecting';
                break;
              case WebSocket.OPEN:
                connectionStatusEl.textContent = 'Connected';
                connectionStatusEl.className = 'status-connected';
                break;
              case WebSocket.CLOSING:
              case WebSocket.CLOSED:
                connectionStatusEl.textContent = 'Disconnected';
                connectionStatusEl.className = 'status-disconnected';
                break;
            }
          }
          
          // Update players online count
          const playerCount = Object.keys(players).length;
          playersOnlineEl.textContent = `Players: ${playerCount}`;
        }

        // WebSocket connection
        function connectToServer() {
          ws = new WebSocket('wss://codepath-mmorg.onrender.com');
          updateHUD(); // Update HUD when connecting
          
          ws.onopen = function() {
            console.log('Connected to game server');
            updateHUD(); // Update HUD when connected
            joinGame();
          };
          
          ws.onmessage = function(event) {
            const message = JSON.parse(event.data);
            handleServerMessage(message);
          };
          
          ws.onclose = function() {
            console.log('Disconnected from server');
            updateHUD(); // Update HUD when disconnected
            // Attempt to reconnect after 3 seconds
            setTimeout(connectToServer, 3000);
          };
          
          ws.onerror = function(error) {
            console.error('WebSocket error:', error);
            updateHUD(); // Update HUD on error
          };
        }

        // Send join game message
        function joinGame() {
          const joinMessage = {
            action: 'join_game',
            username: 'Kushi',
            avatar: {
              name: 'default_avatar',
              frames: {
                north: ['data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg=='],
                south: ['data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg=='],
                east: ['data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==']
              }
            }
          };
          ws.send(JSON.stringify(joinMessage));
        }

        // Handle server messages
        function handleServerMessage(message) {
          console.log('Received server message:', message);
          
          switch(message.action) {
            case 'join_game':
              if (message.success) {
                myPlayerId = message.playerId;
                players = message.players;
                avatars = message.avatars;
                myPlayer = players[myPlayerId];
                console.log('Joined game successfully. My player:', myPlayer);
                updateViewport();
                loadAvatarImages();
                updateHUD(); // Update HUD when joined
              } else {
                console.error('Join game failed:', message.error);
              }
              break;
              
            case 'player_joined':
              players[message.player.id] = message.player;
              avatars[message.avatar.name] = message.avatar;
              loadAvatarImages();
              updateHUD(); // Update HUD when player joins
              break;
              
            case 'players_moved':
              console.log('Players moved:', message.players);
              Object.assign(players, message.players);
              // Update viewport if my player moved
              if (message.players[myPlayerId]) {
                myPlayer = message.players[myPlayerId];
                console.log('My player moved to:', myPlayer.x, myPlayer.y);
                updateViewport();
                updateHUD(); // Update HUD when player moves
              }
              break;
              
            case 'player_left':
              delete players[message.playerId];
              updateHUD(); // Update HUD when player leaves
              break;
              
            default:
              console.log('Unknown message type:', message.action);
          }
        }

        // Load avatar images from base64 data
        function loadAvatarImages() {
          let imagesToLoad = 0;
          let imagesLoaded = 0;
          
          Object.values(avatars).forEach(avatar => {
            Object.values(avatar.frames).forEach(frames => {
              frames.forEach((base64Data, index) => {
                if (typeof base64Data === 'string' && base64Data.startsWith('data:')) {
                  imagesToLoad++;
                  const img = new Image();
                  img.src = base64Data;
                  // Store the loaded image back in the frames array
                  img.onload = function() {
                    frames[index] = img;
                    imagesLoaded++;
                    console.log(`Loaded avatar image ${imagesLoaded}/${imagesToLoad}`);
                    // Don't call draw() here since we have animation loop
                  };
                  img.onerror = function() {
                    console.error('Failed to load avatar image:', base64Data.substring(0, 50) + '...');
                    imagesLoaded++;
                  };
                }
              });
            });
          });
          
          if (imagesToLoad === 0) {
            console.log('No avatar images to load');
          }
        }

        // Update viewport to center on player
        function updateViewport() {
          if (!myPlayer) return;
          
          const now = Date.now();
          // Throttle viewport updates to avoid excessive logging
          if (now - lastViewportUpdate < 100) return;
          lastViewportUpdate = now;
          
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          
          // Calculate viewport offset to center player
          viewportX = myPlayer.x - centerX;
          viewportY = myPlayer.y - centerY;
          
          // Constrain to map boundaries
          viewportX = Math.max(0, Math.min(viewportX, MAP_SIZE - canvas.width));
          viewportY = Math.max(0, Math.min(viewportY, MAP_SIZE - canvas.height));
          
          // Debug logging (throttled)
          console.log('Viewport updated:', {
            playerPos: { x: myPlayer.x, y: myPlayer.y },
            viewport: { x: viewportX, y: viewportY },
            canvas: { width: canvas.width, height: canvas.height }
          });
        }

        function resizeCanvasToWindow() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          updateViewport();
        }

        function draw() {
          // Clear the canvas
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          if (!imageLoaded) {
            return;
          }

          // Draw the world map with viewport offset
          ctx.drawImage(worldImage, -viewportX, -viewportY);

          // Draw all players
          Object.values(players).forEach(player => {
            drawPlayer(player);
          });
        }

        function drawPlayer(player) {
          const screenX = player.x - viewportX;
          const screenY = player.y - viewportY;
          
          // Only draw if player is visible on screen
          if (screenX < -50 || screenX > canvas.width + 50 || 
              screenY < -50 || screenY > canvas.height + 50) {
            return;
          }

          const avatarSize = 32;
          const x = screenX - avatarSize / 2;
          const y = screenY - avatarSize;

          // Get avatar data
          const avatar = avatars[player.avatar];
          let frame = null;
          
          if (avatar) {
            // Get current frame
            const direction = player.facing || 'south';
            const frames = avatar.frames[direction];
            if (frames && frames[player.animationFrame || 0]) {
              frame = frames[player.animationFrame || 0];
            }
          }
          
          // Draw avatar or fallback
          if (frame && frame instanceof Image) {
            // Draw loaded avatar image
            if (player.facing === 'west') {
              // Flip east frames horizontally for west direction
              ctx.save();
              ctx.scale(-1, 1);
              ctx.drawImage(frame, -x - avatarSize, y, avatarSize, avatarSize);
              ctx.restore();
            } else {
              ctx.drawImage(frame, x, y, avatarSize, avatarSize);
            }
          } else {
            // Draw fallback colored rectangle
            ctx.fillStyle = player.id === myPlayerId ? '#00ff00' : '#ff0000'; // Green for me, red for others
            ctx.fillRect(x, y, avatarSize, avatarSize);
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, avatarSize, avatarSize);
          }

          // Draw username label
          ctx.fillStyle = 'white';
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 2;
          ctx.font = '12px Arial';
          ctx.textAlign = 'center';
          
          const textX = screenX;
          const textY = screenY - avatarSize - 5;
          
          ctx.strokeText(player.username, textX, textY);
          ctx.fillText(player.username, textX, textY);
        }

        function handleResize() {
          resizeCanvasToWindow();
          draw();
        }

        window.addEventListener('resize', handleResize);

        worldImage.onload = function () {
          imageLoaded = true;
          handleResize();
        };

        // Movement system
        function startMovement() {
          if (movementInterval) return; // Already moving
          
          console.log('Starting movement loop');
          movementInterval = setInterval(() => {
            if (pressedKeys.size === 0 || !ws || ws.readyState !== WebSocket.OPEN) {
              stopMovement();
              return;
            }
            
            // Send move command for the first pressed key (prioritize first pressed)
            const movementKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyW', 'KeyS', 'KeyA', 'KeyD'];
            for (const key of movementKeys) {
              if (pressedKeys.has(key)) {
                let direction = null;
                switch(key) {
                  case 'ArrowUp':
                  case 'KeyW':
                    direction = 'up';
                    break;
                  case 'ArrowDown':
                  case 'KeyS':
                    direction = 'down';
                    break;
                  case 'ArrowLeft':
                  case 'KeyA':
                    direction = 'left';
                    break;
                  case 'ArrowRight':
                  case 'KeyD':
                    direction = 'right';
                    break;
                }
                
                if (direction) {
                  const moveMessage = {
                    action: 'move',
                    direction: direction
                  };
                  console.log('Sending move command:', moveMessage);
                  ws.send(JSON.stringify(moveMessage));
                }
                break; // Only send one direction per interval
              }
            }
          }, MOVEMENT_INTERVAL);
        }

        function stopMovement() {
          if (movementInterval) {
            clearInterval(movementInterval);
            movementInterval = null;
          }
          
          if (ws && ws.readyState === WebSocket.OPEN) {
            const stopMessage = {
              action: 'stop'
            };
            ws.send(JSON.stringify(stopMessage));
          }
        }

        // Keyboard event handling
        function handleKeyDown(event) {
          if (pressedKeys.has(event.code)) return; // Already pressed
          
          const movementKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyW', 'KeyS', 'KeyA', 'KeyD'];
          if (movementKeys.includes(event.code)) {
            pressedKeys.add(event.code);
            startMovement();
          }
          
          // Prevent default browser behavior (scrolling)
          event.preventDefault();
        }

        function handleKeyUp(event) {
          if (!pressedKeys.has(event.code)) return; // Not pressed
          
          pressedKeys.delete(event.code);
          
          // If no movement keys are pressed, stop movement
          const movementKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyW', 'KeyS', 'KeyA', 'KeyD'];
          const anyMovementKeyPressed = movementKeys.some(key => pressedKeys.has(key));
          
          if (!anyMovementKeyPressed) {
            stopMovement();
          }
          
          event.preventDefault();
        }

        function handleWindowBlur() {
          // Stop all movement when window loses focus
          pressedKeys.clear();
          stopMovement();
        }

        // Animation loop for smooth rendering
        function animate() {
          draw();
          requestAnimationFrame(animate);
        }

        // Initialize
        handleResize();
        connectToServer();
        animate(); // Start the animation loop
        
        // Add keyboard event listeners
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        window.addEventListener('blur', handleWindowBlur);
      })();
    </script>
  </body>
  </html>


